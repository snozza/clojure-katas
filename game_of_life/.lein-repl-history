empty-board
(empty-board 6 6)
(populate (empty-board 6 6) #{[1 0] [2 0] [3 0]}
})
(populate (empty-board 6 6) #{[1 0] [2 0] [3 0]})
(populate (empty-board 6 6) #{[1 0] [2 0] [3 0] [4 0] [5 0]})
(populate (empty-board 6 6) #{[1 0] [2 0] [3 0] [4 0] [5 0] [6 0]})
(populate (empty-board 6 6) #{[1 0] [2 0] [3 0] [4 0] [5 0]})
exit
(use 'game_of_life.core :reload)
(use 'game_of_life :reload)
(use 'game_of_life.core :reload)
(use 'game-of-life.core :reload)
(pprint glider)
(use 'game-of-life.core :reload)
neighbours
(neighbours 1 2)
(neighbours [1, 2])
(neighbours [0, 0])
for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]
(for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]
(println dx dy))
(for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]
(println dx dy))
(not= 1 1 1)
(not= 1 1 2)
(not= 1 1 )
(use 'game-of-life.core :reload)
count-neighbours
(count-neighbours (glider))
(count-neighbours)
(count-neighbours 1)
(count-neighbours [1])
(count-neighbours glider [0 1])
(count-neighbours glider [0 2])
(count-neighbours glider [0 3])
(count-neighbours glider [3 3])
(count-neighbours glider [2 2])
(defn count-ne
[board loc]
(count (neighbours loc))
)
(count-ne glider [1 1])
(count-ne glider [2 2])
(count-ne glider [2 3])
(use 'game-of-life.core :reload)
(-> (iterate indexed-step glider) (nth 8) pprint)
(-> (iterate indexed-step glider) (nth 20) pprint)
(-> (iterate indexed-step glider) (nth 1) pprint)
(-> (iterate indexed-step glider) (nth 8) pprint)
(-> (iterate indexed-step glider) (nth 9) pprint)
(-> (iterate indexed-step glider) (nth 8) pprint)
(use 'game-of-life.core :reload)
(-> (iterate indexed-step glider) (nth 8) pprint)
(-> (iterate indexed-step glider) (nth 9) pprint)
(-> (iterate indexed-step glider) (nth 10) pprint)
(-> (iterate indexed-step glider) (nth 0) pprint)
(-> (iterate indexed-step glider) (nth 1) pprint)
(-> (iterate indexed-step glider) (nth -1) pprint)
(-> (iterate indexed-step glider) (nth 0) pprint)
(count glider)
(glider)
glider
(-> (iterate indexed-step glider) (nth 5) pprint)
(-> (iterate indexed-step glider) (nth 6) pprint)
(-> (iterate indexed-step glider) (nth 7) pprint)
(-> (iterate indexed-step glider) (nth 9000) pprint)
(-> (iterate indexed-step glider) (nth 20000) pprint)
(-> (iterate indexed-step glider) (nth 100000) pprint)
(-> (iterate indexed-step glider) (nth 30000) pprint)
(-> (iterate indexed-step glider) (nth 20000) pprint)
(-> (iterate indexed-step glider) (nth 10000) pprint)
(-> (iterate indexed-step glider) (nth 500) pprint)
(-> (iterate indexed-step glider) (nth 100) pprint)
(-> (iterate indexed-step glider) (nth 200) pprint)
(-> (iterate indexed-step glider) (nth 50) pprint)
(-> (iterate indexed-step glider) (nth 1) pprint)
(-> (iterate indexed-step glider) (nth 19) pprint)
(-> (iterate indexed-step glider) (nth 10) pprint)
(-> (iterate indexed-step glider) (nth 11) pprint)
(-> (iterate indexed-step glider) (nth 12) pprint)
(-> (iterate indexed-step glider) (nth 13) pprint)
(-> (iterate indexed-step glider) (nth 14) pprint)
(-> (iterate indexed-step glider) (nth 15) pprint)
(-> (iterate indexed-step glider) (nth 16) pprint)
(use 'game-of-life.core :reload)
(-> (iterate indexed-step glider) (nth 16) pprint)
(-> (iterate indexed-step glider) (nth 1) pprint)
(-> (iterate indexed-step glider) (nth 14) pprint)
(-> (iterate indexed-step glider) (nth 12) pprint)
(-> (iterate indexed-step glider) (nth 3) pprint)
(-> (iterate indexed-step glider) (nth 4) pprint)
(-> (iterate indexed-step glider) (nth 8) pprint)
(-> (iterate indexed-step glider) (nth 5) pprint)
(-> (iterate indexed-step glider) (nth 4) pprint)
(use 'game-of-life.core :reload)
(-> (iterate indexed-step glider) (nth 4) pprint)
(-> (iterate indexed-step glider) (nth 6) pprint)
(-> (iterate indexed-step glider) (nth 4) pprint)
(use 'game-of-life.core :reload)
(-> (iterate indexed-step glider) (nth 4) pprint)
(use 'game-of-life.core :reload)
(-> (iterate indexed-step glider) (nth 4) pprint)
(-> (iterate indexed-step glider) (nth 15) pprint)
(-> (iterate indexed-step glider) (nth 20) pprint)
(use 'game-of-life.core :reload)
(-> (iterate indexed-step glider) (nth 20) pprint)
(-> (iterate indexed-step glider) (nth 11) pprint)
(-> (iterate indexed-step glider) (nth 10) pprint)
(use 'game-of-life.core :reload)
(-> (iterate indexed-step glider) (nth 10) pprint)
(-> (iterate indexed-step glider) (nth 11) pprint)
(glider 1)
(glider 1 2)
(glider [1 ]2)
(glider [1 2])
(glider [0 2])
glider
glider 1 2
1
2
glider (1 2)
(first glider)
(first (first glider))
(nth (first glider) 2)
(nth (first glider) 3)
(nth (first glider) 1)
(for [x (range h) y (range w)] [x y])
(for [x (range 10) y (range 10)] [x y])
(nth (iterate indexed-step glider) 8)
(nth (iterate index-free-step glider) 8)
(nth (iterate index-free-step glider) 9)
(nth (iterate index-free-step glider) 20)
(nth (iterate index-free-step glider) 22)
(use 'game-of-life.core :reload)
{:hello 1}
{:hello 1, bye: 2}
{:hello 1, :bye 2}
